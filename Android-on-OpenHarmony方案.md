# Android-on-OpenHarmony 技术方案调研

## 背景

任务：调研 OpenHarmony 上运行 Android 的可行性方案。

同事建议：移植 Docker 到 OpenHarmony，在 Docker 里运行 Android 虚拟机。

---

## 同事方案的问题

**Docker + Android 虚拟机 = 套娃架构**

```
OpenHarmony (Linux 内核)
  → Docker (容器，进程隔离，共享内核)
    → Android 虚拟机 (需要完整内核模拟)
```

核心问题：
1. **概念混淆**：Docker 是容器（进程隔离），不是虚拟机（硬件模拟）
2. **嵌套虚拟化**：容器里跑 VM 需要 KVM 支持，OpenHarmony 内核未必开启
3. **性能损耗**：两层隔离叠加，开销巨大
4. **复杂度爆炸**：Docker 移植 + QEMU/KVM 移植 + Android 镜像适配

---

## 三种可行方案对比

| 方案 | 原理 | 隔离级别 | 性能 | 复杂度 | 代表项目 |
|------|------|----------|------|--------|----------|
| **容器化** | 共享内核，隔离用户态 | 进程级 | ★★★★★ | 中 | Anbox, Waydroid, iSulad |
| **虚拟机** | 完整内核隔离 | 硬件级 | ★★☆☆☆ | 高 | QEMU, crosvm |
| **兼容层** | API 翻译/转换 | 无隔离 | ★★★★☆ | 很高 | Wine 思路, 方舟编译器 |

---

## 推荐方案：iSulad + 容器化 Android

### 为什么选 iSulad 而不是 Docker

| 特性 | Docker | iSulad |
|------|--------|--------|
| 开发语言 | Go | C |
| 内存占用 | ~100MB | ~15MB |
| 启动速度 | 秒级 | 毫秒级 |
| 嵌入式适配 | 差 | 好 |
| OpenHarmony 生态 | 外来物种 | 华为亲儿子 |

iSulad 是华为开源的轻量级容器引擎，专为边缘/嵌入式设计，与 OpenHarmony 生态天然契合。

### 技术架构

```
┌─────────────────────────────────────────────────────┐
│                   应用层                             │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  │
│  │ OH 原生应用  │  │ Android App │  │ Android App │  │
│  └─────────────┘  └──────┬──────┘  └──────┬──────┘  │
├───────────────────────────┼────────────────┼────────┤
│                           │    Android 容器 │        │
│  OpenHarmony              │  ┌─────────────┴─────┐  │
│  用户态                    │  │ ART Runtime       │  │
│                           │  │ Android Framework │  │
│                           │  │ Bionic libc       │  │
│                           │  │ SurfaceFlinger    │  │
│                           │  └─────────────┬─────┘  │
├───────────────────────────┼────────────────┼────────┤
│                    iSulad 容器引擎                   │
├─────────────────────────────────────────────────────┤
│                    桥接层 (关键)                     │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐          │
│  │ Binder   │  │ Graphics │  │ Input    │          │
│  │ 透传     │  │ 透传     │  │ 桥接     │          │
│  └──────────┘  └──────────┘  └──────────┘          │
├─────────────────────────────────────────────────────┤
│              OpenHarmony Linux 内核                  │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐          │
│  │ Binder   │  │ DRM/GPU  │  │ Input    │          │
│  │ Driver   │  │ Driver   │  │ Subsys   │          │
│  └──────────┘  └──────────┘  └──────────┘          │
└─────────────────────────────────────────────────────┘
```

### 关键技术挑战

#### 1. Binder 驱动
- Android 核心 IPC 机制，没有 Binder 就没有 Android
- OpenHarmony 内核需要开启 `CONFIG_ANDROID_BINDER_IPC`
- 或使用 binderfs 在容器内挂载

#### 2. 图形渲染
- **方案 A**：软件渲染（性能差，但简单）
- **方案 B**：GPU 透传（需要 DRM/KMS 桥接）
- **方案 C**：virgl（虚拟 GPU，中等性能）

#### 3. 输入事件
- 需要把 OpenHarmony 的输入事件转发到 Android 容器
- evdev 或 uinput 桥接

#### 4. 音频
- PulseAudio 或直接 ALSA 透传

---

## 内接口 vs 外接口

```
┌─────────────────────────────────────────┐
│             OpenHarmony 系统             │
│                                         │
│  ┌─────────────────────────────────┐   │
│  │        Android 容器              │   │
│  │                                 │   │
│  │  ┌─────────┐    ┌─────────┐    │   │
│  │  │ App A   │    │ App B   │    │   │
│  │  └────┬────┘    └────┬────┘    │   │
│  │       │              │         │   │
│  │  ┌────┴──────────────┴────┐    │   │
│  │  │   Android Framework    │    │   │
│  │  └───────────┬────────────┘    │   │
│  │              │                 │   │
│  │      ┌───────┴───────┐        │   │
│  │      │   内接口       │        │   │  ← 容器内部：Android 标准接口
│  │      │  (Binder/HAL) │        │   │
│  │      └───────┬───────┘        │   │
│  └──────────────┼────────────────┘   │
│                 │                     │
│         ┌───────┴───────┐            │
│         │   外接口       │            │  ← 容器边界：OH ↔ Android 桥接
│         │  (桥接层)      │            │
│         └───────┬───────┘            │
│                 │                     │
│  ┌──────────────┴──────────────┐     │
│  │   OpenHarmony 系统服务        │     │
│  │  (图形/输入/音频/网络)        │     │
│  └─────────────────────────────┘     │
└─────────────────────────────────────────┘
```

**内接口**：Android 容器内部保持标准 Android 架构
- Binder IPC
- HAL 层
- Android Framework 标准 API

**外接口**：容器与宿主系统的桥接层
- 图形：SurfaceFlinger ↔ OpenHarmony 窗口系统
- 输入：evdev 转发
- 音频：ALSA/PulseAudio 桥接
- 网络：veth 或 macvlan

---

## 工作量估算

| 阶段 | 工作内容 |
|------|----------|
| **P0** | iSulad 在 OpenHarmony 上运行 |
| **P1** | 最小 Android rootfs 在容器里启动 |
| **P2** | Binder 驱动配置 |
| **P3** | 图形输出（先软渲染） |
| **P4** | 输入事件桥接 |
| **P5** | GPU 硬件加速 |
| **P6** | 音频、摄像头等外设 |

---

## 参考项目

1. **Anbox** - Ubuntu 上的 Android 容器方案
2. **Waydroid** - 基于 LXC 的 Android 容器，支持 Wayland
3. **iSulad** - https://gitee.com/openeuler/iSulad
4. **redroid** - 云端 Android 容器方案

---

## 权限要求：必须是系统级

**核心结论：不能作为普通 App 存在，必须是系统级集成。**

### 为什么普通 App 做不了

| 需要的能力 | 普通 App | 系统级 | 原因 |
|------------|----------|--------|------|
| 启动容器进程 | ❌ | ✅ | 需要 clone() + namespace |
| 挂载文件系统 | ❌ | ✅ | mount() 需要 CAP_SYS_ADMIN |
| 访问 Binder 驱动 | ❌ | ✅ | /dev/binder 权限 |
| 创建网络设备 | ❌ | ✅ | veth 需要 CAP_NET_ADMIN |
| GPU 设备访问 | ❌ | ✅ | /dev/dri/* 权限 |

容器技术本质是**内核特性**（namespace、cgroup、capabilities），普通 App 沙箱里摸不到这些。

### 实际架构

```
┌────────────────────────────────────────────┐
│           用户可见                          │
│  ┌──────────────────────────────────────┐  │
│  │  Android 兼容环境 (看起来像个 App)    │  │
│  └──────────────────────────────────────┘  │
├────────────────────────────────────────────┤
│           实际实现                          │
│  ┌─────────────┐    ┌─────────────────┐   │
│  │ 前端 App    │ ←→ │ 系统服务(守护进程)│   │
│  │ (普通权限)  │IPC │ (root/系统权限) │   │
│  └─────────────┘    └────────┬────────┘   │
│                              │             │
│                     ┌────────┴────────┐   │
│                     │ iSulad + 容器    │   │
│                     └─────────────────┘   │
└────────────────────────────────────────────┘
```

用户交互的可以是普通 App（壳），但后端必须有**系统服务/守护进程**在高权限下管理容器。

### 对项目的影响

这意味着：
1. **需要修改 OpenHarmony 系统镜像**，不是装个 App 就能用
2. 或者做成「系统能力」由**设备厂商预装**
3. 普通开发者/用户**无法自行安装**
4. 需要**系统集成级别的支持**，不是应用层能搞定的事

---

## 结论

同事的「Docker + Android 虚拟机」方案**概念混淆**，不推荐。

推荐方案：**iSulad + 容器化 Android**
- 利用 OpenHarmony 与 Android 共享 Linux 内核的优势
- 轻量级，适合嵌入式场景
- 华为生态内技术栈，便于支持

核心难点在**桥接层**（外接口）：图形、输入、Binder 的透传/桥接。
